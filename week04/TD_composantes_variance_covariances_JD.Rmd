---
title: "TP Estimation des composantes de la variance"
author: "Institut Agro, J. Salomon"
date: "2025"
output:
  rmdformats::readthedown:
    highlight: kate
  html_document:
    toc: yes
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
  word_document: default
editor_options: 
  chunk_output_type: inline
---


```{r}
rm(list = ls())
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Temps d'exécution (voir l'annexe) :
```{r time_0}
t0 <- proc.time()
```


```{r}
packages <- c("nadiv", "rmarkdown", "MM4LMM", "ggplot2")

# Installer packages s'ils ne sont pas déjà installés
for (package in packages) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
  suppressPackageStartupMessages(library(package, character.only = TRUE))
}
```


```{r}
# definir votre chemin à vous
setwd("~/Documents/PhD_Jemay/work/Universite-Quisqueya/UniQG-2026/week04/")
```


# TP Estimation des composantes de la variance

# Objectifs du travail

Ce TP est centré sur l'estimation des composantes de la variance génétique et des *breeding values* des individus.
  
Chez les plantes, il est facile de maîtriser les généalogies en organisant des plans de croisements plus ou moins complexes et l'analyse de variance est alors basée sur les effets parentaux et leurs interactions. Chez les animaux, la maîtrise de plans de croisements aussi structurés que chez les plantes est difficile, voire impossible, si ce n'est chez les huitres ou les poissons. Il s'est développé alors une autre méthode qui se base l'écriture d'une matrice de covariance des effets génétiques entre tous les individus étudiés. La covariance phénotypique entre individus est alors reliée à une matrice d'apparentement et à une hypothèse sur la distribution des effets génétiques. 
  
C'est cette approche qui sera explorée dans ce TD avec deux jeux de données: l'un simulé et l'autre réel sur des croisements de maïs (disponible dans le package R `MM4LMM`).

# 1 . Simulation des données selon un plan de croisement factoriel
Dans une première partie, nous allons simuler des données d’un plan de croisement factoriel. 

L’espèce est allogame. On utilise des plantes mâles, (en nombre *nmal*), que l’on croise avec des plantes femelles, (*nfem*) et on obtient un certain  nombre de descendants par croisement (*nind*).


## 1.1	Bases du modèle 

Répondez aux questions posées
 
  
- Décrivez les structures des familles obtenues.
  
- Sous quel régime de reproduction pouvez-vous écrire le modèle ?
  
- Quelle sera la matrice de variance-covariance entre individus d'après le modèle génétique ?
  

## 1.2.	Simulation des données

Une fonction **Factoriel** permet de simuler des données selon le modèle précédent.

Les données sont simplement générées par des tirages dans des lois normales pour les différents effets et assemblées ensuite pour créer une variable phénotypique.  

Il n'y a pas d'intérêt à expliquer le code dans le cadre de ce TD. Vous pourrez le reprendre à tête reposée si vous voulez le comprendre et l'améliorer.



```{r, include=FALSE}

Factoriel<-function(va, vd, ve, nmal, nfem, nind) {
# Ce bloc effectue les tirages des valeurs génétiques paternelles, maternelles et individuelles 
# La fonction rnorm simule des tirages dans une loi normale 
# la syntaxe rnorm( nombre_de_tirage , mean=moyenne, sd= ecart_type)

# tirage des effets paternels (on les centre sur la moyenne)
pere<-rnorm(nmal, mean=100, sd=(0.25*va)**0.5)

# tirage des effets maternels (centrés sur 0)
mere<-rnorm(nfem , mean=0, sd=(0.25*va)**0.5)

# tirages des effets d’interactions entre les parents  (centrés sur 0)
pere_mere<-rnorm(nmal*nfem, mean=0,sd=(0.25*vd)**0.5)

# tirages des effets individuels intra-familiaux à savoir génétique intra et environnementaux  (centrés sur 0)

ind<-rnorm(nmal*nfem*nind, mean=0, sd=(0.5*va + 0.75*vd +ve)**0.5)

# Ce bloc crée les différentes colonnes du futur fichier de données
# il y aura donc nmal x nfem x nind lignes dans le fichier
# le fichier comportera une colone avec le code du male (P comme père) 
# de la femelle (M comme mère), des individus (I), de Y la variable 
# phenotypique et d'un code (C)

P<-rep(NA, nmal*nfem*nind)
M<-rep(NA, nmal*nfem*nind)
I<-rep(NA, nmal*nfem*nind)
C<-rep(NA, nmal*nfem*nind)
Y<-rep(NA, nmal*nfem*nind)

# Triple boucle pour construire Y = Pere+ Mere + Individus/Croisement + Environnement
i<-0
for (m in 1:nmal) { 
  for(f in 1:nfem)  { 
      for(k in 1:nind) { 
      i<-i+1
      Y[i] = pere[m] + mere[f] + pere_mere[(m-1)*nfem+f] + ind[(m-1)*nfem*nind + (f-1)*nind +k] 
      P[i] = paste("m",m,sep="_")
      M[i] = paste("f",f,sep="_")
    	I[i]=  paste("I",k,f,m, sep=".")
      C[i]=(m-1)*nfem*nind + (f-1)*nind +k
}}}

# Assemblage dans un objet de type data.frame
D<-as.data.frame(cbind(C, P, M, I))
names(D)<-c("Code", "Pere", "Mere", "Individu")
D$Pheno<-as.numeric(Y)
return(D)
}

```
  
   
## 1.3.	Utilisation de la fonction
  
Il est par contre important que vous saisissiez les paramètres que 
vous allez utiliser pour simuler les données. 
  
Vous êtes maître du jeu. Vous pouvez spécifier les valeurs de la variation génétique additive (notation $\sigma_a^2$ ou Va), de dominance ($\sigma_d^2$ ou Vd) et environnementale ($\sigma_e^2$ ou Ve).
  
On fait ici l'hypothèse que les mâles et les femelles sont issus de la même population et ont donc les mêmes propriétés de variance.
  
Choisissez les valeurs de la variance génétique et environnementale.
  
```{r}
va=1
vd=1
ve=1

```
  
Choisissez ensuite les effectifs des parents mâles (nmal) et  femelles (nfem) impliqués dans le factoriel ainsi que le nombre d'individus (nind) dans chaque croisement.
  
```{r}
# valeurs initiales 5, 2, 2
nmal=10
nfem=10
nind=5
```
  
et exécutez la fonction pour créer un fichier de données. 
  
```{r}
D<-Factoriel(va=va,vd=vd,ve=ve,nmal=nmal,nfem=nfem,nind=nind)

head(D)
```
   
Combien d'individus ont-ils été créés ?
  
A combien de famille plein-frères et demi-frères cela correspond-il ?
  
Rappelez combien valent les cov(FS), les cov(HS) par les pères et par les mères dans une population panmictique non consanguine.


# 2.	Utilisation des matrices d’apparentement

## 2.1 Contexte

Il s'agit d'explorer le modèle utilisant les matrices d'apparentement et qui est qualifié historiquement comme le "modèle animal".

Le modèle complet prend en compte les effets additifs et d'interaction entre allèles au même locus (appelés par abus effets de dominance). Il s'écrit de la manière suivante :  

$$y  = \mu +X \beta + Z_au_a + Z_du_d +  \epsilon$$

où  

- $y$ est le vecteur des observations  

- $\mu + \beta X$ sont les effets fixes,  

- $Z_a$ et $Z_d$ les matrices d'incidence qui relient les données aux génotypes.  

- $u_a$  un vecteur d'effets aléatoires polygéniques additifs, qui sont en fait les *breeding values* des génotypes distribués selon la loi $u_a \sim N \left(0,2\phi_a\sigma_a^2\right)$ où la matrice de variance-covariance due aux effets additifs se décompose d'après le modèle génétique en:  
    + (1) $\sigma_a^2$ qui représente la variance polygénique des effets additifs et 
    + (2) $\phi_a$, la matrice $\left(n\ \times \ n\right)$ des coefficients de simple parenté entre les génotypes,  
  
- $u_d$  un vecteur d'effets aléatoires polygéniques de dominance, distribués selon la loi $u_d \sim N \left(0,\phi_d\sigma_d^2\right)$ où la matrice de variance-covariance due aux effets de dominance se décompose d'après le modèle génétique en 
    + (1) $\sigma_d^2$ qui représente la variance polygénique des effets de dominance (interaction) entre allèles au même locus et 
    + (2) $\phi_d$, la matrice $\left(n\ \times\ n\right)$ des coefficients de double parenté entre les génotypes. 

Il est très fréquent de voir ce modèle écrit dans une version simplifiée (sans les effets de dominance) : 

$$y  = \mu + \beta X + Zu + \epsilon$$

où $u$ est un vecteur d'effets aléatoires polygéniques additifs et $Z$ la matrice d'incidence qui relie les observations $y$ aux $u$.  
Le vecteur *u* est en fait $u_a$ du modèle précédent,  distribué selon $u \sim N \left(0,A\sigma_a^2\right)$ où $\sigma_a^2$ représente la variance polygénique des effets additifs et **A** directement la matrice $\left(n\ \times\ n\right)$ des relations (relationship matrix en anglais), et dans ce cas elle désigne directement les $2\phi_a$, faites bien attention à la définition que l'auteur d'un package R donne à la "relationship matrix", à la "kinship matrix" : le coefficient multiplicateur 2 peut être inclus ou pas par exemple. 

Dans ce TD, nous allons donc nous attacher à construire les matrices à partir des parentés connues (pédigrés). La matrice $A$ peut aussi s'estimer à partir de données de marqueurs, par exemple avec l'estimateur proposé par Van Raden ($A$ prend alors le nom de $K$ pour Kinship).   
La matrice $A\sigma_a^2$ est une matrice de variance covariance qui donne les covariances entre les valeurs génétiques additives ou breeding values (cov($u_{a}^{(x)}$,$u_{a}^{(y)}$)). De même, on peut définir la matrice $D$ à partir des $\phi_d$ et $D\sigma_d^2$ donne les covariances entre les valeurs génétiques de dominance-interaction (cov($u_{d}^{(x)}$,$u_{d}^{(y)}$)).


## 2.2 Construction des matrices d’apparentement

Il s’agit de calculer une ou plusieurs matrices d’apparentement, PhiA ($\phi_a$) ou PhiD ($\phi_d$).
  
Nous allons utiliser le package **nadiv**  pour cela. Il peut calculer une matrice à partir d’un pedigree.
  
Un fichier de pedigree se compose simplement d’un identifiant, d’un père (sire en anglais) et d’une mère (dam en anglais aussi) en référence à la génétique animale. Exemple :
  
$$\begin{matrix}
   Id & Sire & Dam \\
   A & Aldebert & Gertude\\
   B & Aldebert & Cunégonde\\
   C & Mr X & Cunégonde\\
\end{matrix}$$
  
  
Comme tous les individus doivent être référencés, les derniers ancêtres communs connus ont aussi des ascendants mais ils sont inconnus, donc ils reçoivent des valeurs NA pour leur père (sire) et leur mère (dam). NB: $MrX$ sera NA aussi pour ses parents). 
  
Ainsi il est facile de constituer le pedigree des individus simulés.

```{r}
# il faut fabriquer le fichier de pedigree
Pedigree<-as.data.frame(cbind(as.character(D$Individu), as.character(D$Pere), as.character(D$Mere)))

names(Pedigree)<-c("id","Sire","Dam")
head(Pedigree)
```
## Exemple : Construction d’un pedigree simple et matrices A et D

Considérons quatre individus : A, B, C et D.

Le pédigrée est :

- A > B  (A est le parent de B)
- C -- D (C et D sont pleins frères)
- Nous n’avons aucune information sur la parenté A,C AD, BC ou BD donc toutes leur
covariances sont nulles :

Les deux familles sont indépendantes.

Nous voulons construire les matrices :

- MA = apparentement additif  
- MD = apparentement dominance  

La matrice suivante montre les contributions :

\[
\begin{array}{c|cccc}
 & A & B & C & D \\
\hline
A &
\,V_P &
\tfrac12\,V_A &
0 &
0 \\
B &
\tfrac12\,V_A &
\,V_P &
0 &
0 \\
C &
0 &
0 &
\,V_P &
\tfrac12 V_A + \tfrac14 V_D \\
D &
0 &
0 &
\tfrac12 V_A + \tfrac14 V_D &
\,V_P
\end{array}
\]

Ainsi :

- \(\mathrm{Cov}(A,B)=\frac12 V_A\) (relation parent–enfant)
- \(\mathrm{Cov}(C,D)=\frac12 V_A + \frac14 V_D\) (pleins-frères)
- toutes les autres covariances = 0 (familles indépendantes)


## Matrice d’apparentement additive A

Le coefficient d’apparentement vaut :
- 1 pour un individu avec lui-même
- 1/2 pour une relation parent–enfant
- 1/2 pour des pleins frères
- 0 sinon

Ainsi :

\[
MA =
\begin{pmatrix}
1   & \tfrac{1}{2} & 0             & 0             \\
\tfrac{1}{2} & 1   & 0             & 0             \\
0   & 0   & 1             & \tfrac{1}{2} \\
0   & 0   & \tfrac{1}{2} & 1
\end{pmatrix}
\]


## Matrice d’apparentement dominance D

Rappel :
- dominance = 1 entre un individu et lui-même
- dominance = 1/4 entre pleins-frères
- domination = 0 pour parent–enfant
- dominance = 0 si non-apparentés

Ainsi :

\[
MD =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & \tfrac{1}{4} \\
0 & 0 & \tfrac{1}{4} & 1
\end{pmatrix}
\]

  
Pour utiliser le package nadiv qui va fabriquer les matrices de simple et de double apparentement (PhiA=Kinship and PhiD=fraternity/Dominance) il faut ajouter l'information sur les parents dont nous ne connaissons pas les parents *a priori*.   
Nous Utilisons la fonction *prepPed* de **nadiv** qui va les ajouter. 


  
```{r}
Ped<-prepPed(Pedigree)
```
  
La fonction *makeD* va ensuite calculer les matrices de simple (simple parenté, Kinship)  et de double parenté D (double parenté, fraternity). Appelons les MA et MD.
  
```{r}
MAT<-makeD(Ped, parallel = FALSE, ncores = getOption("mc.cores", 2L), invertD = FALSE, returnA = TRUE, det = TRUE)

MA<-MAT$A
MD<-MAT$D

MA[1:5, 1:5]
MD[1:5, 1:5]
```
  
Il nous reste à enlever les parents pour lesquels nous n'avons pas de données phénotypiques. Nous enlevons donc les lignes et les colonnes correspondant aux pères et aux mères. 
  
```{r}
D$Mere <- as.factor(D$Mere)
D$Pere <- as.factor(D$Pere)
liste<- rownames(MA) %in% levels(D$Mere) | rownames(MA) %in% levels(D$Pere)
MA<-MA[!liste,]
MD<-MD[!liste,]

liste<- colnames(MA) %in% levels(D$Mere) | colnames(MA) %in% levels(D$Pere)
MA<-MA[,!liste]
MD<-MD[,!liste]

```
  

La matrice sortie de *makeD* est une matrice "creuse" qu'il faut remettre dans un formalisme que vous connaissez mieux. 
  
```{r}
MA<-as.matrix(MA)
MD<-as.matrix(MD)

MA[1:10,1:5]
MD[1:10,1:5]

```
  
Regardez MA.  
  
A-t-elle les coefficients $\phi_A$ que vous attendiez ?
Que vaut MA en réalité ?

Regardez MD. Et ?
  

De quelle dimension est-elle ?  
```{r}
dim(MA)
```
  
  
## 2.3 Estimation des composantes de la variance
  
Nous pouvons maintenant utiliser le package **MM4LMM** pour l'estimation des composantes de la variance. 
Tout d'abord le vecteur des valeurs phénotypiques. 
```{r,fig.height=3}
y<-D$Pheno
names(y)<-D$Individu
length(y)

ggplot(D, aes(x=y))+
  geom_histogram(color="darkred", fill="pink",bins=7) +
  ggtitle("Distribution de la variable simulée")
```
  
Pour déclarer la matrice de covariance pour l'estimation de la variance résiduelle, nous créons une matrice identité. Cela signifie que tous les effets environnementaux et génétiques intra familles sont réellement indépendants les uns des autres. Vous auriez pu mettre les voisinages de rang 1 par exemple pour estimer une ressemblance locale (mais il faut créer une autre matrice). 
  
I est une matrice qui est carrée dont le nombre de dimensions est égale au nombre d'observations.  
  
```{r}
I<-diag(length(y))

I[1:5,1:5]
dim(I)

```
  
  
Le package **MM4LMM**  est très souple pour l'utilisation des matrices de covariance.  
Dans un premier temps nous utilisons seulement la matrice PhiA.  
  
```{r}

# Pour être sur que vous avez compris...
# PhiA<-MA/2
# A <- 2*PhiA

A <- MA

# modele A + D

##Build the VarList object
VL <- list(Additive = A , Dominance=MD, within =I)
ZL <- list(Za=I, Zd=I, Error = I)

##Perform inference
Result <- MMEst(Y=y , ZList=ZL, VarList = VL, Henderson=TRUE)
Result


# la moyenne
Result[[1]]$Beta

# les variances
Result[[1]]$Sigma2

```

Que valent vos estimations de variance additive ?  de dominance ?
Par rapport à ce que vous attendiez ?  

Que contient la variance within ici ?  

## 2.4 BLUPs et breeding values

Nous cherchons à prédire les $u_a$ qui sont les valeurs additives des génotypes étudiés.


Sous la condition de Normalité des effets aléatoires, la formule dite d'Henderson est utilisée pour prédire les $u_a$ sachant les données $y$ est donnée par 

$$
E(u_a|\mathbf{Y}=\mathbf{y})= Var(u_a)\mathbf{Z_a}' \Sigma^{-1} (\mathbf{y}-\mathbf{X}\beta)
$$
où $Var(u_a)$ est la matrice de variance covariance entre valeurs additives des individus, de dimension $(n \times n)$ si n est le nombre de génotypes, La matrice de variance-covariance phénotypique des $y$ est donnée par

$$Var(\mathbf{Y}) = \Sigma = \mathbf{Z_a}Var(u_a)\mathbf{Z_a}' + \mathbf{Z_d}Var(u_d)\mathbf{Z_d}' + Var(\varepsilon)$$
et 

- $\mathbf{Z'}$ désigne la transposée de la matrice d'incidence qui est dans notre cas est toujours la matrice identité ($I$)
- $\Sigma^{-1}$ est l'inverse de la matrice de la variance-covariance phénotypique,  
- $\mathbf{y}-\mathbf{X}\beta$ est le vecteur des valeurs phénotypiques centrée par l'écart aux effets fixes

On peut obtenir les blups selon la formule de Henderson en effectuant le calcul via la formule :

```{r}
# Dans notre cas :
Z= I  
dim(Z)

Vua = A*Result[[1]]$Sigma2[1]
dim(Vua)

Vud = MD*Result[[1]]$Sigma2[2]
dim(Vud)

Vres = I*Result[[1]]$Sigma2[3]
dim(Vres)

Sigma =  Vua + Vud  +Vres 
dim(Sigma)

residus = y-Result[[1]]$Beta
length(residus)

```
et on trouve
```{r}
ua = Vua %*% solve(Sigma) %*% residus
qqnorm(ua); qqline(ua,col="red")
```


de même pour $u_d$

```{r}
ud = Vud %*% solve(Sigma) %*% residus
qqnorm(ud); qqline(ud,col="red")
```
  
  
Leur distribution   
```{r,fig.heigt=3}
blup <- data.frame(ua=ua,ud=ud)

a = ggplot(blup, aes(x=ua))+
  geom_histogram(color="darkblue", fill="lightblue",bins=7)

d= ggplot(blup, aes(x=ud))+
  geom_histogram(color="darkgreen", fill="lightgreen",bins=7)

gridExtra::grid.arrange(a,d,ncol=2)
```

```{r}
# On peut aussi utiliser cette fonction de MM4LMM
# TODO: BlupVA <- MMBlup(Y=y , ZList = ZL, VarList = VL, ResMM=Result)
```


# 3. Exploration (TD - Devoir)

## 3.1 Précision des estimations
  Faites varier le nombre de mâles, de femelles et le nombre d'individus 
  
  Exécutez plusieurs fois (5-10 fois) avec les mêmes paramètres pour vous rendre compte de la puissance de votre dispositif pour estimer les paramètres.  
  

## 3.2 Effets de l'architecture génétique des caractères 
  Modifiez les relations entre les variances  
    - rapport additivité et dominance   
    - Parcourez 3 niveaux d'héritabilité (choisir une valeur par niveau), faible (0.1-0.2), moyenne (0.5-0.6) et fortes (0.8-0.9)  
    
    
## 3.3  Analysez et concluez. 

* Astuces: Collecter les données pour chaque **run** sur unt tableur excel. 
    
##  3.4 Rapport (2-3 page en PDF)

* Une page pour décrire les paramètres de simulations pour chaque **run** puis 1 ou 2 pages pour interprétations

* Indiquer **votre nom et prénom**.  

* **À rendre :** un document (rapport) uniquement le PDF. 

* **À envoyer à : jemay.salomon@inrae.fr**


</div>
# Annexe

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
